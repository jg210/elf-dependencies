#!/usr/bin/env ruby
#
# Copyright 2019 Jeremy Green.

require 'open3'
require 'optparse'
require 'pathname'
require 'shellwords'

class Options

  def self.default_objdump
    objdump = `which objdump`.chomp.freeze
    if objdump.empty?
      return nil
    else
      return Pathname.new(objdump)
    end
  end

  def initialize(argv)
    tool_name = Pathname.new(__FILE__).basename.to_s.freeze
    @objdump = self.class.default_objdump()
    parser = OptionParser.new do |opts|

      opts.on("--objdump path",
              "The location of the objdump tool. Def") do |path|
        @cache_path = Pathname.new(path)
      end              
      
    end
    parser.banner = <<EOF

usage: #{tool_name} [<options>] [--] <so-paths>

EXAMPLES

#{tool_name.shellescape} `find /usr/lib -maxdepth 1 -type f -name '*.so*' -not -name ld.so.conf`

EOF

    non_option_args = parser.parse!(argv)
    @paths = non_option_args.map { |arg| Pathname.new(arg) }

    # TODO validate options
  end

  attr_reader :objdump
  attr_reader :paths
  
end

class Libs

  def initialize(options, paths)
    libs = paths.map do |path|
      Lib.new(options, path)
    end
    @libs = {}
    libs.each do |lib|
      soname = lib.soname
      raise "multiple libs with same soname: #{soname}" if @libs.include?(soname)
      @libs[soname] = lib
    end
  end

  def lib(soname)
    @libs[soname]
  end

  def to_dot
    puts "digraph deps {"
    @libs.each_value do |lib|
      puts lib.to_dot_dependencies(self)
    end
    puts "}"
  end

end

class Lib

  def self.parse_dependencies(options, path)
    stdout, status = ::Open3::capture2(options.objdump.to_s, '-p', path.to_s) 
    raise status.to_s unless status.success?
    dependencies = []
    soname = nil
    pattern_needed = /  NEEDED +(?<soname>[^ ]*)/
    pattern_soname = /  SONAME +(?<soname>[^ ]*)/
    stdout.each_line do |line|
      match_soname = pattern_soname.match(line)
      if match_soname
        if soname
          raise "found soname of #{soname} more than once in: #{path.shellescape}"
        end
        soname = match_soname[:soname].chomp.freeze
      end
      match_needed = pattern_needed.match(line)
      dependencies << match_needed[:soname].chomp.freeze if match_needed
    end
    dependencies.freeze
    #puts "#{soname} #{dependencies}"
    if soname.nil?
      raise "soname nil for: #{path}"
    end
    return soname, dependencies
  end

  def initialize(options, path)
    @soname, @deps = self.class.parse_dependencies(options, path)
  end

  def soname
    return @soname
  end

  def deps(all_libs)
    @deps.map {|soname| all_libs.lib(soname) }
  end

  def to_dot_dependencies(all_libs)
    dot_strings = self.deps(all_libs).map do |dep|
      "#{self.soname} -> #{dep.soname}".freeze
    end
    return dot_strings.join("\n").freeze
  end
  
end

###############################

options = Options.new(ARGV)
libs = Libs.new(options, options.paths)
libs.to_dot
